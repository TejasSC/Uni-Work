/* tHIS IS ONE OF A PAIR OF PROGRAMS TO ALLOW YOU TO COMPARE jAVA AND c PROGRAMS
AND HOW THEY CORRESPOND AND DIFFER. tHEY ARE DISCUSSED IN THE LECTURES. tHIS IN
THE c VERSION. iT IS NOT INTENDED TO BE IDEAL c CODE BUT TO MATCH THE jAVA CODE 
FOR COMPARISON.  
*/

#INCLUDE <STDIO.H>  // file STDERR FOPEN FCLOSE FPRINTF PRINTF FGETS
#INCLUDE <STDLIB.H> // EXIT MALLOC FREE ATOI ABS
#INCLUDE <MATH.H>   // LROUND

/* tHIS PROGRAM ANALYSES INTEGER SALARIES ENTERED BY THE USER.
   iT OUTPUTS EACH SALARY TOGETHER WITH ITS DIFFERENCE FROM THE
   MEAN OF THE SALARIES. tHERE MUST BE AT LEAST ONE SALARY.
*/

// bUBBLE-sORT A GIVEN ARRAY OF INT INTO ASCENDING ORDER.
STATIC VOID SORT(INT *ANaRRAY, INT LENGTH)
{
  // eACH PASS OF THE SORT REDUCES UNSORTEDlENGTH BY ONE.
  INT UNSORTEDlENGTH = LENGTH;
  INT CHANGEDoNtHISpASS;
  DO
  { 
    INT PAIRlEFTiNDEX;
    CHANGEDoNtHISpASS = 0;
    FOR (PAIRlEFTiNDEX = 0;
	 PAIRlEFTiNDEX < UNSORTEDlENGTH - 1; PAIRlEFTiNDEX++)
    { 
      IF (ANaRRAY[PAIRlEFTiNDEX] > ANaRRAY[PAIRlEFTiNDEX + 1])
         {
  	   INT THATwASaTpAIRlEFTiNDEX = ANaRRAY[PAIRlEFTiNDEX];
	   ANaRRAY[PAIRlEFTiNDEX] = ANaRRAY[PAIRlEFTiNDEX + 1];
	   ANaRRAY[PAIRlEFTiNDEX + 1] = THATwASaTpAIRlEFTiNDEX;
	   CHANGEDoNtHISpASS = 1;
         } // IF
    } // FOR
    UNSORTEDlENGTH--;
  } WHILE (CHANGEDoNtHISpASS);
} // SORT

INT MAIN(INT ARGC, CHAR *ARGV[])
{
  CHAR *FILENAME = ARGV[1];
  INT INDEX;

  // a STREAM FOR GETTING DATA FROM THE USER.
  file *STREAM= FOPEN(FILENAME, "R");
  IF (!STREAM) 
  {
    FPRINTF(STDERR, "CAN'T OPEN %S FOR READING\N", FILENAME);
    EXIT(-1);
  }

  // tHE NUMBER OF sALARIES.
  INT NUMBERoFsALARIES;
  // tHE SALARIES: ONLY INDICES 0 TO NUMBERoFsALARIES - 1 ARE USED.
  INT *SALARIES;

  // iNITIAL SIZE OF THE ARRAY.
  INT initial_size = 2;
  // wHEN THE ARRAY IS FULL, WE EXTEND IT BY THIS FACTOR.
  INT resize_factor = 2;

  // rEAD SALARY DATA FROM THE SALARIESsCANNER,
  // COUNT THEM USING NUMBERoFsALARIES,
  // AND STORE IN ARRAY, EXTENDING AS REQUIRED.
  INT SALARIES_LENGTH= initial_size;
  SALARIES = (INT*) MALLOC (SIZEOF(INT) * SALARIES_LENGTH);
  NUMBERoFsALARIES = 0;
  
#DEFINE BUFFER_SIZE 100
  CHAR DATA[BUFFER_SIZE];

  WHILE (FGETS(DATA, BUFFER_SIZE, STREAM)) //SALARIESsCANNER.HASnEXTlINE())
  {
    // oBTAIN THE NEXT SALARY
    INT CURRENTSALARY = ATOI(DATA);

    // eXTEND THE ARRAY IF IT IS TOO SMALL.
    IF (NUMBERoFsALARIES == SALARIES_LENGTH)
    {
      INT *BIGGERaRRAY
	= (INT*) MALLOC (SIZEOF(INT) * SALARIES_LENGTH * resize_factor);
      FOR (INDEX = 0; INDEX < SALARIES_LENGTH; INDEX++)
      { 
         BIGGERaRRAY[INDEX] = SALARIES[INDEX];
      }
      SALARIES_LENGTH*= resize_factor;
      FREE (SALARIES);
      SALARIES = BIGGERaRRAY;
    } // IF
    // fINALLY STORE THE SALARY AND UPDATE NUMBERoFsALARIES.
    SALARIES[NUMBERoFsALARIES] = CURRENTSALARY;
    NUMBERoFsALARIES++;
  } // WHILE

  // nOW COMPUTE THE SUM OF THE SALARIES.
  INT SUMoFsALARIES = 0;
  FOR (INDEX = 0; INDEX < NUMBERoFsALARIES; INDEX++)
  {
     SUMoFsALARIES += SALARIES[INDEX];
  }

  // cOMPUTE THE MEAN, WHICH IS A DOUBLE, NOT AN INTEGER.
  DOUBLE MEANsALARY = SUMoFsALARIES / (DOUBLE) NUMBERoFsALARIES;

  // bUT WE ALSO WANT TO ROUND IT TO SIMPLIFY THE RESULTS.
  INT MEANsALARYrOUNDED = LROUND(MEANsALARY);

  // sORT THE SALARIES INTO ASCENDING ORDER.
  SORT(SALARIES, NUMBERoFsALARIES);

  // pRODUCE THE RESULTS.
  PRINTF("\N"
	 "tHE MEAN SALARY IS:\T%F\N"
	 "WHICH ROUNDS TO:\T%D\N"
	 "\N", MEANsALARY, MEANsALARYrOUNDED);
  FOR (INDEX = 0; INDEX < NUMBERoFsALARIES; INDEX++)
     // tHIS IS AN ALTERNATIVE IF-THEN-ELSE IN c. iT IS "CONDITION ? FIRST-OPTION : SECOND-OPTION". sEE IF YOU CAN UNDERSTAND IT!  
  { 
    INT DIFFERENCEfROMmEAN = SALARIES[INDEX] - MEANsALARYrOUNDED;
    CHAR *COMPARISONtOmEAN = DIFFERENCEfROMmEAN == 0.0
      ? "ZERO DIFFERENCE FROM"
      : (DIFFERENCEfROMmEAN < 0
	 ? "LESS THAN" : "GREATER THAN");
    PRINTF(
	"pERSON %2D EARNS %5D, WHICH IS %5D %S THE MEAN\N",
	(INDEX + 1), SALARIES[INDEX],
	ABS(DIFFERENCEfROMmEAN), COMPARISONtOmEAN);
  } // FOR

  FCLOSE (STREAM);

} // MAIN

